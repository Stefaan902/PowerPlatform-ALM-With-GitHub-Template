name: test
# Test

on:
  workflow_dispatch:
  
jobs:
  test:
    runs-on: windows-latest
    env:
      solution_name: PowerPlatformALMWithGitHub
      solution_checker_result_output_directory:  solutionchecker/
      RUNNER_DEBUG: 1

    steps:
    - name: Set variable
      run: |
        echo "TEST=Hello world!" >> $Env:GITHUB_ENV
    
    - name: Use variable
      run: |
        echo "${Env:TEST}"

    - name: Set powerapps_environment_domain_name as env variable
      run: echo "::set-env name=path_to_solution_zip_file::out/Solutions/${{ env.solution_name }}.zip"
      
    - uses: actions/checkout@v2
      with:
        lfs: true

    - name: Pack solution
      uses: microsoft/powerplatform-actions/pack-solution@v0
      with:
        solution-folder: Solutions/${{ env.solution_name }}
        solution-file: ${{ env.path_to_solution_zip_file }}
        solution-type: Unmanaged

    - name: Get PowerShell modules
      shell: powershell
      run: |
        Install-Module -Name Microsoft.PowerApps.Administration.PowerShell -Force -Verbose -Scope CurrentUser
        Install-Module -Name Microsoft.PowerApps.PowerShell -AllowClobber -Force -Verbose -Scope CurrentUser
        Install-Module -Name Microsoft.PowerApps.Checker.PowerShell -Force -Verbose -Scope CurrentUser

    - name: Invoke solution checker
      shell: powershell
      run: |
        New-Item -ItemType Directory -Force -Path ${{ env.solution_checker_result_output_directory }}

        $pass = ConvertTo-SecureString "${{ secrets.DEV_USER_PASSWORD }}" -AsPlainText -Force
        Add-PowerAppsAccount -Username ${{ secrets.DEV_USER_LOGIN }} -Password $pass
        
        $rulesets = Get-PowerAppsCheckerRulesets -Geography Canada
        $rulesetToUse = $rulesets | where Name -NE 'AppSource Certification'
        
        $analyzeResult = Invoke-PowerAppsChecker -Geography Canada -ClientApplicationId '${{ secrets.APPLICATION_ID }}' `
          -TenantId '${{ secrets.TENANT_ID }}' -Ruleset $rulesetToUse -FileUnderAnalysis "${{ env.path_to_solution_zip_file }}" `
          -OutputDirectory "${{ env.solution_checker_result_output_directory }}" -ClientApplicationSecret (ConvertTo-SecureString -AsPlainText -Force -String '${{ secrets.CLIENT_SECRET }}')

    - name: Test
      shell: powershell
      run: |
        Get-ChildItem "${{ env.solution_checker_result_output_directory }}" -Filter *.zip | Expand-Archive -DestinationPath '${{ env.solution_checker_result_output_directory }}' -Force

        $sarif_files = Get-ChildItem "${{ env.solution_checker_result_output_directory }}" -Filter *.sarif

        foreach ($sarif_file in $sarif_files)
        {
            $SolutionCheckerResultJson = Get-Content -Path ${{ env.solution_checker_result_output_directory }}/$sarif_file
        }

        $SolutionCheckerResult = $SolutionCheckerResultJson | ConvertFrom-Json

        $results = $SolutionCheckerResult.runs.results

        $nbOfMediumSeverityPoints = 0
        $nbOfHighSeverityPoints = 0

        $results.foreach(
          {
            if($_.properties.severity -eq "Medium")
            {
              $nbOfMediumSeverityPoints++
            }
            elseif($_.properties.severity -eq "High")
            {
              $nbOfHighSeverityPoints++
            }
          }
        )

        echo "NB_OF_MEDIUM_SEVERITY_POINTS=$nbOfMediumSeverityPoints" >> $Env:GITHUB_ENV
        echo "NB_OF_HIGH_SEVERITY_POINTS=$nbOfHighSeverityPoints" >> $Env:GITHUB_ENV
        
    - name: Exit
      if: Env.NB_OF_MEDIUM_SEVERITY_POINTS < 3
      run: exit 1

  test2:
    name: test2
    needs: test
    runs-on: windows-latest
    if: always() # set always
    env:
      RUNNER_DEBUG: 1

    steps:
        # run this action to get workflow conclusion
        # You can get conclusion via env (env.WORKFLOW_CONCLUSION)
      - uses: technote-space/workflow-conclusion-action@v1

      - name: Not played
        if: env.WORKFLOW_CONCLUSION == 'success' # notify only if success
        run: |
          echo "Good?"
          echo "${Env:WORKFLOW_CONCLUSION}"